# Практическое задание по теме «Многопоточность».

## Описание 
**Курс Go-разработчик с нуля на платформе ЯндексПрактикум. Модуль 4. Спринт 9. Итоговое задание.**

 В задании нужно будет применить базовые знания:
- запуск горутин;
- создание и работа с контекстом WithTimeout();
- запись данных в канал и чтение из него;
- распределение работы между несколькими горутинами;
- применение sync.WaitGroup для ожидания окончания работы горутин;
- использование конструкции select;
- применение range для чтения данных из канала.

## Запуск приложения
Для запуска приложения необходимо:
 - Ввести команду  `go build -o goroutine`
 - Запустить приложение командой `./goroutine `

## Техническое задание 
Задача звучит так. Имеется горутина, которая генерирует числа и отправляет их в канал. Дальше несколько горутин читают и раскидывают их по нескольким каналам. В конце происходит обратный процесс: все числа из каналов пишутся в один результирующий канал.
Нужно, чтобы количество и сумма входящих чисел совпало с количеством и суммой чисел, которые получены из канала вывода.

## Комментарии к фрагментам кода

#### **1. Функция Generator**
Функция должна генерировать числа и записывать их в канал `ch`. Для каждого числа должна быть вызвана функция `fn()`. Используйте такой алгоритм генерации:

```
- N(0) = 1;
- N(i) = N(i-1) + 1
```
`Generator()` прекращает работу, когда поступил сигнал об отмене контекста `ctx`.

#### **2. Функция Worker()**
Эта функция обрабатывает числа. Она должна читать числа из канала `in` до тех пор, пока он не закроется. Полученное число нужно записать в канал `out` и сделать паузу на 1 миллисекунду. Если канал `in` закрылся, то нужно закрыть канал `out` и завершить работу функции.

#### **3. Создание контекста**
Здесь необходимо создать контекст `ctx`, который должен самостоятельно отмениться через одну секунду.

#### **4. Собираем числа из каналов outs**
В этом фрагменте нужно пройтись по всем каналам из слайса `outs` и для каждого из них запустить горутину с анонимной функцией. Горутина должна читать данные из переданного ей канала, до тех пор, пока он не закроется. Чтобы дождаться завершения всех этих горутин, нужно воспользоваться механизмом `WaitGroup`. Горутина должна подсчитывать обработанные числа (увеличивать соответствующий счётчик в слайсе `amounts`) передавать значения в канал `chOut`.

#### **5. Читаем числа из результирующего канала**
Осталось прочитать все данные из канала `chOut`. При этом нужно подсчитать в переменной `count` общее количество чисел, а в переменной `sum` — сумму всех чисел.

#### 6. **Исправляем потенциальное состояние гонки**
Вроде ваше программа работает и выдаёт ожидаемые результаты; но в коде есть кусок, который может привести к состоянию гонки, если программа изменится. Попробуйте найти проблемный фрагмент самостоятельно, прежде чем читать дальше.

## Проверка результатов
После добавления необходимого кода и успешной отработки, программа должна вывести в консоль примерно такие строки:
```txt
Количество чисел 4558 4558
Сумма чисел 10389961 10389961
Разбивка по каналам [913 912 913 910 910]
```

У вас значения будут другими, но числа в первой и второй строчках, которые указаны через пробел, должны совпадать. Числа слайса `amount` должны быть практически одинаковыми. Они показывают, сколько значений передалось через соответствующий канал `outs[i]`. Если через один канал прошло, например, 800 чисел, а через другой — 900, это сигнал о неполадках.
Вы можете изменить значение константы `NumOut` и сравнить результаты при `NumOut`, равной 2, 5, 10, 15. Видно, что чем больше используется горутин, тем больше чисел обрабатывается в сумме, но при этом каждая горутина обрабатывает меньше чисел.
